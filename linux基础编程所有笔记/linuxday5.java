

阻塞和非阻塞
	阻塞：等待条件满足
	非阻塞；不等
=-========	================================================
==========阻塞和非阻塞是文件的属性还是read函数的属性？
阻塞和非阻塞:是文件的属性

open函数第一个参数一定是带路径的文件名
eg：open（“/dev/tty”，buf ，10）
	read（STDIN_FILEN,buf,10)
终端设备：/dev/tty
	默认阻塞：管道，套接字
	指定阻塞属性：O_NONBLOCK













1. Linux文件操作相关函数
	stat函数 *****
							穿透(追踪)函数 -- 软链接
				=====================================================
				==	 #include <sys/types.h>
				==	 #include <sys/stat.h>
				==	 #include <unistd.h>
				==	
				==	 int stat(const char *pathname, struct stat *buf);
				==	 int fstat(int fd, struct stat *buf);
				==	 int lstat(const char *pathname, struct stat *buf);
				======================================================
			
				=====================================================
				 pathname：带路径的文件
			  	 struct stat *buf：这是个传出参数
			  	        / 
					    #include <sys/stat.h>
					     #include <unistd.h>
					   
					     int stat(const char *pathname, struct stat *buf);
					     
					  穿透(追踪)
			
			
			
					     int fstat(int fd, struct stat *buf);
					   
					    这个第一个参数，用的是文件描述符，暨open打开的文件，或是在文件描述符表里面的
					    例如  
			
			
			
			
			
			
			
			
					     int lstat(const char *pathname, struct stat *buf);不穿透(不追踪)
					  <1>lstat和stat的区别在于读取软练级暨S_IFLNK
					  	stat会读到底，而lstat 只会读软连接
				======================================================
			
	STAT结构体！！！！！！！！！！
					======================================================	==================================
					==  struct stat {																				==	
					==        dev_t     st_dev;         //文件的设备编号											==	
					==        ino_t     st_ino;         节点--->inode---->机器不认名字，只认inode						
					==        mode_t    st_mode;       ===文件的类型和存取的权限									==	
					==        nlink_t   st_nlink;       //连到该文件的硬连接数目， 刚建立的文件值为1				==	
					==        uid_t     st_uid;        ===用户ID													==	
					          gid_t     st_gid;        ===组ID												        ==
					==        dev_t     st_rdev;        //(设 备类型)若此文件为设备文件，则为其设备编号			    ==	
					==        off_t     st_size;       ===文件字节数(文件大小)										==	
					==        blksize_t st_blksize;     //块大小(文件系统的I/O缓冲 区大小)							==	
					==        blkcnt_t  st_blocks;      //块 数												     	==	
																											        ==	
					==        /* Since Linux 2.6, the kernel supports nanosecond									==	
					==           precision for the following timestamp fields.										==	
					==           For the details before Linux 2.6, see NOTES. */									==	
																											        ==	
					==         struct timespec st_atim;  //最后一次访问时间									     	==																			
					==        struct timespec st_mtim;  =-== 最后一次修改时间										==
					==        struct timespec st_ctim;  //最后一次改变时间----》 多指创建时间						==
																											        ==
					==    #define st_atime st_atim.tv_sec      /* Backward compatibility */					     	==											
					==    #define st_mtime st_mtim.tv_sec															==
					==    #define st_ctime st_ctim.tv_sec														    ==
					==    };
					== ======================================================	===================================
							
			
			        mode_t    st_mode;       ===文件的类型和存取的权限	
			        16位：4+3+3+3+3
  4：有关文件类型的宏：--------->这些宏，直接被头文件包含，若果你想知道某个文件有没有对应的属性，直接&该宏
				 ===============================================
			     == S_IF+									  ==
			     ==     8进制   文  特 U  G  O				  ==
			     == SOCK：0  X  14  0  0  0  0 套接字     12  ==
			     == LNK： 0  X  12  0  0  0  0 符号链接：10	  ==
			     == REG： 0  X  10  0  0  0  0 普通文件	8	  ==
			     == BLK： 0  X  06  0  0  0  0 块设备	6	  ==
			     == DIR： 0  X  04  0  0  0  0 目录 	4	  ==
			     == CHR： 0  X  02  0  0  0  0 字符设备 	2 ==
			     == IFO： 0  X  01  0  0  0  0 管道 	1	  ==
			     ===============================================
			     ==	3+3+3：USR GRP OTH 						  ==
			     ==	S_I+R/W/X+USR GRP OTH 					  ==
				 == 										  ==
			     ==	按照相对位置 USR GRP OTH   0 X 0 0 0 4	  ==
			     ===============================================
			
			
access函数：检测当前用户对这个文件是否具有某种属性
			  检测权限是否拥有，以及pathname是否存在
			------》检测当前用户是否拥有权限，R_OK W_OK X_OK F_OK
			       #include <unistd.h>
			       int access(const char *pathname, int mode);
			
			       eg:  int access("./english.txt" R_OK|W_OK|X_OK|F_OK);
			
			
chmod函数
			
			
			        #include <sys/stat.h>
			
			       int chmod(const char *path, mode_t mode);
			       int fchmod(int fd, mode_t mode);
			
			------->bash有一个内建的chmod ，和这个的参数刚好相反
			
			
			
 chown函数：修改文件所有者，和所属组
				#include <unistd.h>
			
			       int chown(const char *path, uid_t owner, gid_t group);
			       int fchown(int fd, uid_t owner, gid_t group);
			       int lchown(const char *path, uid_t owner, gid_t group	
			
			       	l：不穿透，f是fd
			
			
truncate函数：修改文件大小，暨拓展文件，，和lseek不一样！----》lessk最后还需要进行写入一下
			
			
				   #include <unistd.h>
			       #include <sys/types.h>
			
			       int truncate(const char *path, off_t length);
			       int ftruncate(int fd, off_t length);
			
			       	参数：path：文件名
			       		  length：文件的最终大小
			       		  		<1>比原来小，删除后面的部分
			       		  		<2>比原来打，向后拓展--使用占位符@^
			
			
			
			
			patsubst
			
			
			
			

======================
链接函数
			link函数
			symlink函数
			readlink函数
			unlink函数	*****
		rename函数


2. Linux 目录操作相关函数

			<1>rename函数	:改名函数
				 #include <stdio.h>
				 int rename(const char *oldpath, const char *newpath);
				 老名字--->新名字
			<2>chdir函数：切换当前进程（应用程序）的路径 --->和cd差不多
						参数：切换的路径
					限定：是修改进程的路径
					
			==========================================================================================================
			===		举例：在当前路径下运行一个函数，该函数变成进程，然后chdir切换进程路径，然后在当前目录下创建一个文件
			===		等到该进程退出，当前bash的目录下并没有该文件
			=====================================================================================================
			<3>getcwd函数：获取当前进程所在目录
					  #include <unistd.h>
			
			       char *getcwd(char *buf, size_t size);
			
			       char *getwd(char *buf);
			
			       char *get_current_dir_name(void);
			
			       参数：char *buf：当前路径信息所在的缓冲区
			       		  size_t size；缓冲区的大小--->相当于sizeof（buf）
			<4>mkdir函数：
				   #include <sys/stat.h>
			       #include <sys/types.h>
			
			       int mkdir(const char *pathname, mode_t mode);
			       ：指定的mode还需要和umask掩码进行操作
			       ----->mode&~umask&0777
			<5>rmdir：删除空目录
				   #include <unistd.h>
			
			       int rmdir(const char *pathname);





3.目录遍历相关操作

<1>opendir：打开一个目录 ：man 3


	   #include <sys/types.h>
       #include <dirent.h>

       DIR *opendir(const char *name);
       DIR *fdopendir(int fd);
       参数：目录名
       返回值：指向目录的指针


<2>读目录-->readdir函数

目录项结构体！！！

			=====================================================================================================
			==		struct dirent {																			   ==								
			==               ino_t          d_ino;       ===此目录进入点的inode ，也就是这个目录的inode    	   ==								
			==               off_t          d_off;      ===目录文件开头至此目录进入点的位移				       ==				
			==               unsigned short d_reclen;    /===d_name的长度，不包含NULL字符					   ==				
			==               unsigned char  d_type;      d_name所指文件的类型（7中文件类型）				   ==					
			==                                              												   ==
			==               char           d_name[256]; /* filename */										   ==
			==           };																					   ==					
			=====================================================================================================
  

  -----d_type对应的宏
 		    ===========================================
 		  	==	DT_BLK      	||		 块设备  	 ==	
 		  	==	DT_CHR		 	||		 字符设备  	 ==	
 		  	==	DT_DIR 	 	    ||		 目录  		 ==	
 		  	==	DT_LNK		 	||		 软连接  	 ==	
 		  	==	DT_FIFO	 	    ||		 管道  		 ==	
 		  	==	DT_REG		 	||		 普通文件  	 ==	
 		  	==	DT_SOCK 	 	||		 套接字  	 ==	
 		  	==	DT_UNKNOWN  	||		 未知  		 ==	
 		    =========================================== 
 		  												
readdir本质就是：读取目录项结构体
--->如果需要遍历某个目录下面的所有文件，则需要递归
--->使用opendir   readdir，来判断文件类型，如果是目录的话，需要读取该目录的子目录
--->子目录：
 

     int readdir(unsigned int fd, struct old_linux_dirent *dirp, unsigned int count);
 		这个是系统函数



		！/=====================================================================
		！/  #include <dirent.h>

		！/     struct dirent *readdir(DIR *dirp);
		！/     参数：dirp---》是opendir的返回值
		！/     	返回值是一个，目录项结构体指针

		！/     	通过  目录项结构体变量指针，结合宏，来进行类型确认，
		！/=====================================================================


*

						====================================================

*****************         TAT结构体        DIRENT结构体        DIR结构体          ******************************
****************************************************************************************************************
T==T						                 	以实现 LL 为例子											T==T									 
T==T============================================================T==T										T==T																	
T==T	 DIR *opendir(const char *name);						T==T		readdir根据DIR来实现     		T==T																										
T==T															T==T										T==T																		
T==T															T==T		每调用一次该函数，就读取		T==T																		
T==T	 循环：struct dirent *readdir(DIR *dirp);				T==T										T==T																											
T==T															T==T		下一个该目录下的文件	    	T==T																		
T==T															T==T										T==T																		
T==T	 int stat(const char *pathname, struct stat *buf);		T==T										T==T																													
T==T															T==T		然后通过dirent结构体			T==T																		
T==T============================================================T==T										T==T																																
T==T															——————————————————————	判断是否是目录文件	T==T												
T==T																				==						T==T															
T==T								==================								==	如果是，就递归		T==T																						
T==T																				==	（子目录，通过当前	T==T																
T==T									dirent结构体								==	目录，在加上读到的	T==T																		
T==T	===============				==================								==	目录生成新的名字）	T==T																			
T==T																				==						T==T												
T==T		DIR结构体																==						T==T														
T==T	===============											==================	==		最后通过stat	T==T																						
T==T																STAT结构体		==		获得详细信息	T==T																	
T==T															==================	==						T==T																																																
T==T——————————————————————————————————————————————————————————————————————————————————————————————————————— T==T																	
T==T																											
																												
																												
																												
																												
																												
																												
																												
																												
																												
																												
																												



		
3. fcntl 函数
		改变已经打开的文件的属性
		
			打开文件的时候: 只读
					修改文件的: 添加追加 O_APPEND

				
4. dup, dup2函数
				复制现有的文件描述符
		
		
		
		
		  		#include <unistd.h>
		
		       int dup(int oldfd);
		       int dup2(int oldfd, int newfd);----->可以指定文件描述符
		
		
		       dup：参数：现有的一个文件描述符，
		       		返回值：从空闲的文件描述符表中，找一个最小的文件描述符，接受复制信息
		
		       ------>一旦复制成功，新的fd会指向oldfd 的file结构体，之后file结构体的连接计数+1，
		       ------>新老fd都是指向同一个file结构体，所以可以操作同一个文件
--------------------->：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。 








		|| ==================================================================================================================
		|| 
		|| 解决gcc编译过程中c99语法报错的问题
		|| ~/.bashrc
		|| alias gcc='gcc -std=gnu99'
		|| ==================================================================================================================
		|| 索引节点inode：保存的其实是实际的数据的一些信息，这些信息称为“元数据”(也就是对文件属性的描述)。
		|| 例如：文件大小，设备标识符，用户标识符，用户组标识符，文件模式，扩展属性，文件读取或修改的时间戳，
		|| 链接数量，指向存储该内容的磁盘区块的指针，文件分类等等。
		|| ( 注意数据分成：元数据+数据本身 )
		|| ==================================================================================================================
		|| 注意inode怎样生成的：每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定
		|| (现代OS可以动态变化)，一般每2KB就设置一个inode。一般文件系统中很少有文件小于2KB的，所以预定按照2KB分，
		|| 一般inode是用不完的。所以inode在文件系统安装的时候会有一个默认数量，后期会根据实际的需要发生变化。
		|| ==================================================================================================================
		|| 注意inode号：inode号是唯一的，表示不同的文件。其实在Linux内部的时候，访问文件都是通过inode号来进行的，
		|| 所谓文件名仅仅是给用户容易使用的。当我们打开一个文件的时候，首先，系统找到这个文件名对应的inode号；然后，
		|| 通过inode号，得到inode信息，最后，由inode找到文件数据所在的block，现在可以处理文件数据了。
		|| ==================================================================================================================
		|| inode和文件的关系：当创建一个文件的时候，就给文件分配了一个inode。一个inode只对应一个实际文件，
		|| 一个文件也会只有一个inode。inodes最大数量就是文件的最大数量。
		|| ==================================================================================================================

FILE* fp = open("file");




拓展：
				
				===================================================================================
				==	 																			 ==
				==	 AME(名称)																	 ==
				==	        group - 用户组文件													 ==
				==	 																			 ==
				==	 DESCRIPTION(描述)															 ==
				==	        /etc/group															 ==					
				==	        是一个ASCII码的文件,它定义了用户所属的组.文件中每行包括一条记		 ==
				==	 录,其格式如下:																 ==																					
				==	 																			 ==
				==	               group_name:passwd:GID:user_list								 ==
				==	 																			 ==
				==	        字段描述如下:														 ==
				==	 																			 ==
				==	        group_name															 ==
				==	               组名															 ==
				==	 																			 ==
				==	        password															 ==
				==	               (加密的)组密码.如果该字段为空,则不需要密码.					 ==
				==	 																			 ==
				==	        GID    组的数字标识.												 ==
				==	        user_list															 ==
				==	               组内所有成员的用户名,以逗号分隔.								 ==
				===================================================================================
				
				=================================================================================== 
				==NAME 名称																		 == 
				==       passwd - 密码文件														 == 
				==																				 == 
				==描述																			 == 
				==       Passwd        是个文本文件,       它包含了一个系统帐户列表,			 ==
				==       给出每个帐户一些有用的信息，比如用户  ID,组   ID,   家目录,			 ==
				==       shell,等.             通常它也包含了每个用户经过加密的密码.			 ==
				==       它通常应该是可读的（许多命令，工具程序，象 ls(1) 用它做用户			 ==
				==       Id 到用户名称的映射）,但是只允许超级用户有写方式权限.					 == 
				==																				 == 
				==       在过去美好的日子里，这种一般的读许可没有什么大问题.					 ==
				==       每个人都能读到加密了的密码，因为硬件太慢以至于不能解开一个				 == 
				==       精选的密码，另外，这基本假定是为友好的使用团体使用的.					 == 
				==       现在，许多人运行一些版本的影子密码套件，它们在  /etc/passwd			 ==
				==       的密码域里是     *，而不再是加密的口令，     加密的口令放在			 ==
				==       /etc/shadow 中，那个文件只有超级用户能读．								 == 
				==																				 == 
				==       不管是否使用了影子密码，许多系统管理员使用一个星号在加密的密			 ==
				==码字段																		 ==
				==       以确保用户不能鉴别他（她）自己的密码. (见下面的注意)					 ==													
				==              account:password:UID:GID:GECOS:directory:shell					 == 
				==              （帐号:密码:用户ID:组ID:一般的信息:目录:shell）					 == 
				==																				 == 
				===================================================================================
				
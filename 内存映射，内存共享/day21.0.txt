exec函数族:

IPC：进程间通信，inter process communication
	4种方式：
		·	1.管道---简单(伪文件！)
		·	2.信号--系统开销小
		·	3.共享映射区--(有无血缘关系都可以)
		·	4.本地套接字----稳定
				
				

		:文件（普通文件是非阻塞的）
				
					d 目录
				
					l 符号链接
				
		:伪文件
					s 套接字
				
					b 块设备
				
					c 字符设备
				
					p 管道
				
				
				
>1<管道:  (简单)--->读完就擦
	    ·	1.本质：
	    		1.在内核缓冲区中
	    		2.管道是  为文件。----->不占用磁盘空间
	    ·	2.特点

	           =================================================================================
	    	==
	    	==	1.管道分为两部分，分别对应两个文件描述符
	    	==			1.读端：读出
	    	==			2.写端：写入
	    	==			
	    	==		"       这 是 一 个 环 形 队 列+++++++++++++++马哥数据结构！！！！！
	    	==			 ———————————————————————————————————
	    	==		fd0	|									|	fd1
	    	==			|		<-------------------		|
	    	==			 ———————————————————————————————————
	    	==    "
	    	==			 	
	    	==	2.操作管道的进程，被销毁之后，管道被自动释放 （操作系统级别的）
	    	==	
	    	==	3.管道默认是阻塞的：读写都是默认阻塞的 ！！！
	    	==	
	    	==	4.内部实现方式：队列（环形队列，先进先出）
	    	==	
	    	==	5.大小默认是 4K byte 会适当的调整，是有一定范围的





	    				=========================================================================
	    			"||"PIPE_BUF：4k---->当读写数据小于 PIPE_BUF时，保证读写的原子性
	    			"||"		  什么是原子性： 当前操作不能被打断，不论是读写都不能被打断
	    			"||"		  				------>引申：当前操作要么是完成了，要么是还没有完成，不存在完成一半的情况
	    			"||"
	    			"||"		  				
	    			"||"		  什么是临界资源：PIPE——BUF ：4k是 是临界资源
	    			"||"						同一时刻，当前的资源只能被一个进程所访问；
	    			"||"				如果多个进程同时修改临界资源，会导致数据二义性。
	    			"||"				
	    			"||"				问题！！===+如何保证临界资源访问的合理性，从而不会造成数据二义性
	    			"||"						互斥：同一时间，保证了只能有一个进程访问临界资源
	    			"||"						同步：保证了不同进程对临界资源访问的合理性
					


						=============================================================================
					PIPE_SIZE：64k





	    	==	
	    	==	6.管道的局限性：
	    	==		1.数据只能读取一次，不能重复读取。
	    	==		2.半双工：
	    	==		3.匿名管道只适用于 ---->有血缘关系的 进程
	    	==		
	    		=============================================================================
	    3.创建匿名管道
	    	1.int pipe（int fd[2]);
				-1.fd是一个传出参数，fd是俩文件描述符
				-2.fd【0】----读端
				-3.fd【1】----写端
				-4.！！！pipe要写在fork的前面！ -------->子进程继承父进程的pcb，pcb里面有文件描述符表
		4.父子进程建使用管道
			思考！：
				1.单个进程能否使用管道？
				------= 可以。我甚至可以把管道当成一块内存，专门写垃圾
				2.父子进程之间通信，是否需要sleep函数？
					情景：父进程：写的慢  子进程：读得快

					-------->不需要！  
							---->因为管道默认是  阻塞的

		5.父子进程间通信，很多时候回用到文件重定向，dup/dup2

		6.管道的读写行为：
				-1.读操作
	
				 		 1.1：有数据
				 		 		读端正常读，read返回读出的字节数
				 		 1.2：无数据
				 		 	1.2.1：假设写端全部关闭：read接触阻塞，返回0--->相当于读到文件尾部
				 		 	1.2.2：写端没有被全部关闭：---->read会阻塞，等待写端写入数据
				-2写操作
						2.1：读端全部被关闭：
							 管道破裂，进程终止（内核会给进程发13号信号，会杀死写端）
						
						2.2：读端没有全部被关闭
							2.2.1：缓冲区写满了---->阻塞 等待空位，有空位在写
							2.2.2：缓冲区没有满---->继续写，直到写满
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

							读写行为汇总！
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
			======================================================================================================
			|| 		
			||						几种特殊情况：https://blog.51cto.com/11285984/1835413
			||++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			||				"默认read 和 write 都是 阻塞状态 ，因为文件创建出来默认就是阻塞的"
			========================================================================================================			 
		"	===			 (1)如果	所有指向管道写端	的文件描述符都关闭了，
			===			 而仍然会有进程从管道的读端读数据，那么当管道中的数据被读取完之后，
			===			 再返回0，就像读到文件末尾一样。
			===
			===						
			===
			===			 (2)如果有指向管道写端的文件描述符没关闭，
			===			 而持有管道写端的进程没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据被读取后，
			===			 再次read会被阻塞，直到管道中有数据可读了才读取数据并返回。
			==="
			===			 		 管道的另一端是否关闭，会影响本端，在进行相关操作时，是否会阻塞（eg：写端不关，读端读完就阻塞，等着。读端不关，写端写满就阻塞，等着）
			===					 	（另一端的是否关闭，可以用来判断是否进行  进程间持续通信）（端口的关闭与否，，可以看做一种 握手挥手机制）
			"===	
			===			 (3)如果 所有 指向管道读端		的文件描述符都关闭了，
						
			===			 这时有进程向管道的写端write，
			===			 那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。
			==="
			===		         	管道的读端要比写端高贵，从根本目的上来说，管道就是为读端而服务的    
			===					这也是处于对读端的保护
			"===
			===  				
			===
			===			 (4)如果有指向管道读端的文件描述符没关闭，
			===			 而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写数据，
			===			 那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。
			======================================================================================================================="
			===				更改读写段的状态为非阻塞：下设2种情况
			========================================================================================================================
			===  				1.变更 write 状态为非阻，读端不变
			===
			===			1.1： 一直写入，但是不进行读，并且读端不关闭：（一直写入时因为write是非阻塞的，所以可以一直写）
			===				  write  会返回-1，报错当前资源不可用，
			===			（个人理解：非阻塞会一直写下去，"当队尾遇到队头"，就应该会停下来，若果不停下来，就证明写多了，所以返回-1）
			===					所以报错，但是咱满足大小的范围内，会读取成功（）
			===
			===			1.2： 所有读端直接关闭，
								写端一直写，（没有写入操作，会在最开始被杀死）（"管道的读端要比写端高贵，从根本目的上来说，管道就是为读端而服务的"）
			===					当前京城会受到13号信号，写端会被杀死。（管道破裂了）（管道读端一定要开放）
			===					（读端不要数据时，关闭读端，，杀死写端，这也是一种保护机制）
			===+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			===
			===					2.变更读端，read设置为非阻塞，
			===
			===			2.1：写端不关闭，read一直读，read会返回-1，
			===						(循环双端队列，"队头遇到队尾"，还不停下来，还不要命的读，就会出错)
			=== 		2.2：所有写端关闭
								，读端一直读， read是正常调用的，read会返回到的字节数
			===					("写端关闭，就意味着没有新数据"，队头遇到队尾就停下来)
			================================================================================================================
			===			AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
			===			A 		'管道在使用时，会先检查读写端的引用计数
			===			A					如果读端为0 则破裂
						A					如果写端为0 ，就返回字节数而不是数据流';
						AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
			==================================================================================



		7.查看管道大小：
			1.使用shell命令： ulimit -a 一般默认是4k但是会管道会石洞扩大
			2.函数： fpathconf

				   #include <unistd.h>

     			    long fpathconf(int fd, int name);
       				long pathconf(char *path, int name);
       				参数
       					：fd文件描述符
       					name：   _PC_PIPE_BUF 一大堆宏

       	8.设置管道阻塞状态：
       		（管道的莫一端的彻底阻塞，是要看 这一端的引用计数  4根线1刀切）

       		"=====================>>>>>>>>"	||	fcntl 函数
								||			改变已经打开的文件的属性
								||			int fcntl(int fd, int cmd ....)
								||			参数：fd：文件描述符
								||				   cmd：改变文件描述符属性
								||				打开文件的时候: 只读
								||						修改文件的: 添加追加 O_APPEND
								||	
								||			获取文件flags:
								||					int flags= fcntl(i fd, F_GETFL );
								||			设置文件新的flags：
								||	
								||				flags|=O_NONBLOCK;(设置文件为阻塞状态)
								||				fcntl( fd, F_SETFL,,falgs0
								||	




>2< fifo（和匿名管道一样，默认阻塞）
	
		1.特点：	
			1.1 有名管道：
			1.2 区别于匿名管道
					1.2.1 fifo是在磁盘上的一个文件，，是一个管道文件
						ls -l   会显示一个 p
					
					1.2.2 .fifo也是一个伪文件，fifo的大小永远是0
					1.2.3 .在内核中有一个缓冲区
					1.2.4 .半双工
			
		2.使用场景：没有血缘关系的进程间通信

		3.创建方式：
			<1>第一种： shell命令行
				mkfifo  name

			<2>第二种 函数
				    #include <sys/types.h>
       				#include <sys/stat.h>

     				int mkfifo(const char *pathname, mode_t mode);
     					参数：
     					pathname------>带路径文件名称
     					 mode： 八进制树----->文件权限 mode会& ~umask
     				如果没有则创建，有的话创建失败



     	4.进程间通信：fifo
     	eg：两个不相干进程 a.c b.c
     		a.c---->read
     			int fd =open("myfifo",O_RDONLY);
     			read(fd,buf,sizeof(buf));
     			close(fd);
     		b.c---->write
     			int fd1=open("myfifo",O_WROMLY);
     			write(fd1,"xxxxxxxx",sizeof(xxxxxxx));
     			close(fd1)
     				
			====================================================================================================
								也就相当于从4根线，变成了2根线https://blog.csdn.net/zuoside__lord/article/details/82459472
			||	*（1）open() 以只读方式打开 FIFO 时，要阻塞到某个进程为写而打开此 FIFO；
			||	　  		
			||		
			||			open() 以只写方式打开 FIFO 时，要阻塞到某个进程为读而打开此 FIFO。
			||						简单一句话：
			||						open时	只读等着只写（没有东西就等着），只写等着只读（写满了就等着读出空位），
			||								只有两个都执行到，才会往下执行。
			||		
			||				如果不想在 open() 的时候阻塞，我们可以以可读可写方式打开 FIFO 文件
			||				------->这样 open() 函数就不会阻塞。
			||				------->这是针对于open阻塞相互等待的解决办法
			||				------->解决之后，默认read 和write是阻塞的 管道还是正常的操作
			||"====================================================================================================="				
			||		
			||		2）假如 FIFO 里没有数据，调用 read() 函数从 FIFO 里读数据时 read() 也会阻塞。这个特点和无名管道是一样的。
			||		
			||		3）通信过程中若写进程先退出了，就算命名管道里没有数据，
			||			调用 read() 函数从 FIFO 里读数据时不阻塞；（一根线断掉了，就不是非阻塞的了）（读取成功后，返回读取的数据多少）
			||			若写进程又重新运行，则调用 read() 函数从 FIFO 里读数据时又恢复阻塞。（那根线又连上了）
			||
			||		5）通信过程中，读进程退出后，写进程向命名管道内写数据时，写进程也会（收到 SIGPIPE 信号）退出。
			||					（一根线断掉了，还是读端的那根线，管道破裂）（断线之后，引用计数为0）
			||				(3和5就已经是 一刀斩断所有引用了）（这个引用我是进程保持的，你如果手动关闭这个fd也会出问题，直接退出也会出问题
			||		6）调用 write() 函数向 FIFO 里写数据，当缓冲区已满时 write() 也会阻塞。
			||				（默认阻塞）
			||"======================================================================================================="		
			||		
			||		命名管道可以以非阻塞标志（O_NONBLOCK）方式打开：
			||		fd = open("my_fifo", O_WRONLY|O_NONBLOCK);  
			||		fd = open("my_fifo", O_RDONLY|O_NONBLOCK); 
			
					AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA	
			||				-------- >以此方法打开管道后， 管道就是非阻塞的了
			||				-------- >同时 open也非阻塞了
					AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
			
			||		非阻塞标志（O_NONBLOCK）打开的命名管道有以下特点：
			||		1、先以只读方式打开，如果没有进程已经为写而打开一个 FIFO, 只读 open() 成功，并且 open() 不阻塞。
			||		2、先以只写方式打开，如果没有进程已经为读而打开一个 FIFO，只写 open() 将出错返回 -1。 
			||
			||				------这里并不是13号信号，这么整的话，会认为你创建管道失败
			||				------你可以一直循环来进行  非阻塞open 知道创建成功
			||		3、read()、write() 读写命名管道中读数据时不阻塞。
			||	
			=====================================================================================================================














>3<共享内存
	前置：
		进程虚拟地址空间：
				内核区 
				命令行参数和环境变量
				栈区
				共享区
				堆区
				未初始化常量区（未初始化或初值为0的全局变量和静态局部变量）
				已初始化常量区（已初始化且初值非0的全局变量和静态局部变量）
				data、
				code:字符串常量在这
				save
	共享内存主要就是在共享区：
	共享区，主要是动态库加载的地方

	<1>作用：将磁盘文件映射到内存，用户通过修改内存，就能修改磁盘文件
	
	<2>函数原型MMAP：本质是进行内存映射,暨映射共享

||	=============================================================================
||	     #include <sys/mman.h>	
||		void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); 
||		int munmap(void *addr, size_t length);
||	
||	
||	
||	
||		参数：	
||			addr: 	使用时，直接传递NULL建立映射区的首地址，由Linux内核指定。
||			length： 欲创建映射区的大小
||					----->4k的整数倍
||					----->不能为0
||					----->文件有多大，一般length就有多大
||			prot：	映射区权限 --->营社区必须要有读权限
||				PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE、 PROT_EXEC
||			
||			flags：	标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)
||				  	MAP_SHARED:  会将映射区所做的操作同步到物理设备（磁盘）上。
||				  	MAP_PRIVATE: 映射区所做的修改不会听不到物理设备（磁盘）。
||			
||			fd： 	需要映射的文件所对应的fd
||					（把对应fd的文件扔到 共享区）
||					（需要提前打开文件，从而获得文件描述符)
||			
||			offset： 映射的时候文件指针的偏移量(4k的整数倍)
||					---->一般指定0
		返回：
			成功：返回创建的映射区首地址；
			失败：MAP_FAILED宏
||	=========================================================================================
||		munmp：	释放内存缓冲区：
||			#include <sys/mman.h>
||			int munmap(void *addr, size_t length);	
||			参数：addr，mmap的返回值，内存营社区的首地址
||				 length：mmap的第二个参数，内存营社区的大小
||		
=============================================================


"第二种内存共享机制"
||			#include <sys/ipc.h>
||	       #include <sys/shm.h>
||	"============================================================================================================="
||		"=="       int shmget(key_t key, size_t size, int shmflg);
||		"=="
||		"=="       参数：https://blog.csdn.net/qq_33573235/article/details/79169624
||		"=="       		key：共享内存的标识符
||		"=="       			  key标识共享内存的键值: 0/IPC_PRIVATE ------>自己来个宏定义一串数
||		"=="       				----->管道是面向字节流的，除此之外，其余几个都是面向对象的，key就是对象的key
||		"=="       				----->	如果不使用“键”，进程将无法存取IPC对象，因为IPC对象并不存在于进程本身使用的内存中。
||		"=="       			------	>	常，都希望自己的程序能和其他的程序预先约定一个唯一的键值，但实际上并不是总可能的成行的，因为自己的程序无法为一块共享内存选择一个键值。
||		"=="       						因此，在此把key设为IPC_PRIVATE，这样，操作系统将忽略键，建立一个新的共享内存，指定一个键值，然后返回这块共享内存IPC标识符ID。
||		"=="
||		"=="       		int size(单位字节Byte)
||		"=="       				:  size是要建立共享内存的长度。所有的内存分配操作都是以页为单位的。
||		"=="       					
||		"=="       					拓展知识：
||		"=="       					所以如果一段进程只申请一块只有一个字节的内存，内存也会分配整整一页
||		"=="       					(在i386机器中一页的缺省大小PACE_SIZE=4096字节)
||		"=="       					这样，新创建的共享内存的大小实际上是从size这个参数调整而来的页面大小。
||		"=="       					即如果size为1至4096，则实际申请到的共享内存大小为4K(一页)；4097到8192，
||		"=="       					则实际申请到的共享内存大小为8K(两页)，依此类推。
||		"=="       					(所以上面那个共享映射，也是按照页来申请，所以必是4k整数倍)
||		"=="       		int shmflg
||		"=="
||		"=="       			    IPC_CREAT   如果共享内存不存在，则创建一个共享内存，否则打开操作。
||		"=="    				IPC_EXCL    只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。
||		"=="    							也就是说，如果有了，不会打开
||		"=="    		返回值：
||		"=="    				成功返回共享内存的标识符；
||		"=="    				不成功返回-1，errno储存错误原因。
||		"=="
||		"=="   						 EINVAL        参数size小于SHMMIN或大于SHMMAX。
||		"=="   						 EEXIST        预建立key所致的共享内存，但已经存在。
||		"=="   						 EIDRM         参数key所致的共享内存已经删除。
||		"=="   						 ENOSPC        超过了系统允许建立的共享内存的最大值(SHMALL )。
||		"=="   						 ENOENT        参数key所指的共享内存不存在，参数shmflg也未设IPC_CREAT位。
||		"=="   						 EACCES        没有权限。
||		"=="   						 ENOMEM        核心内存不足。
||		"==""++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
||	
||			
||			struct shmid_ds-----------------------------------------------
||			    shmid_ds数据结构表示每个新建的共享内存。当shmget()创建了一块新的共享内存后，
||			    返回一个可以用于引用该共享内存的shmid_ds数据结构的标识符。
||			在include/linux/shm.h下
||			   
||			
||			  struct shmid_ds{
||			      struct ipc_perm shm_perm;/* 操作权限*/
||			       int shm_segsz;                    /*段的大小（以字节为单位）*/
||			      time_t shm_atime;          /*最后一个进程附加到该段的时间*/
||			       time_t shm_dtime;          /*最后一个进程离开该段的时间*/
||			      time_t shm_ctime;          /*最后一个进程修改该段的时间*/
||			      unsigned short shm_cpid;   /*创建该段进程的pid*/
||			       unsigned short shm_lpid;   /*在该段上操作的最后1个进程的pid*/
||			       short shm_nattch;          /*当前附加到该段的进程的个数*/
||			/*下面是私有的*/
||			        unsigned short shm_npages;  /*段的大小（以页为单位）*/
||			      unsigned long *shm_pages;   /*指向frames->SHMMAX的指针数组*/
||			      struct vm_area_struct *attaches; /*对共享段的描述*/
||			};
||			
||			原文链接：https://blog.csdn.net/qq_33573235/article/details/79169624
||			
||			
||			"=========================================================================================================="
||		"=="shmat：把共享内存附加到当前进程
||		"=="void *shmat(int shmid, const void *addr, int flag);
||		"=="		shmid：共享存储的id，也就是shmget的返回值：该共享内存的句柄看，指向shmid——ds结构体
||		"=="		
||		"=="		addr：一般为0，表示连接到由内核选择的第一个可用地址上，（分配内存的首地址）
||		"=="				否则，如果flag没有指定SHM_RND，则连接到addr所指定的地址上，如果flag为SHM_RND，则地址取整
||		"=="		
||		"=="		flag：如前所述，一般为0
||		"=="				0：可读可写
||		"=="				IPC_RDONLY.：只读
||		"=="		返回值：如果成功，返回共享存储段地址，也就是该共享内存的地址（cxy直接拿着用）
||		"=="				出错返回-1
||		"=="
||		"=="
||		"=="====================>这个时候，就可以用返回值来操作了
||		"==""+++++++++========================================================================================================="
||		shmdt
||		int shmdt(void *addr);
||		shmdt将使相关shmid_ds结构中的shm_nattch计数器值减1
||		
||		
||		====================>在这里，会把共享内存分离掉，返回值没用了。
||		====================>但是共享内存还在，你并没有把他删除，他一直在你的内存中。共享内存的声明周期是跟随操作系统内核的
||			
||	"=================================================================================================================="
||		"=="	shmctl
||		"=="	int shmctl(int shmid,int cmd,struct shmid_ds *buf)
||		"=="	shmid:共享存储段的句柄，=======>直接删除那个结构体
||		"=="	cmd：一些命令，有：IPC_STAT,IPC_RMID,SHM_LOCK,SHM_UNLOCK
||		"=="			IPC_RMID：删除共享内存，标记共享内存为删除状态
||		"=="			获取共享内存状态信息：准确说是直接获取shmid——ds这个结构体
||		"=="			IPC_STAT：获取共享内存信息，只不过需要搭配 shmid_ds*buf 这个出参来使用
||		"=="	
||		"=="	原文链接：https://blog.csdn.net/qq_33573235/article/details/79169624
||		"=="	
||		"=="	请注意，共享内存不会随着程序结束而自动消除，要么调用shmctl删除，要么自己用手敲命令去删除，否则永远留在系统中。
||			
=======================================================================================================



























	=================================================================================================================================================================

	"||"						mmap和shmget对比：https://blog.csdn.net/itworld123/article/details/104462392
	"||"		mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作
	"||"		-------	>	mmap，是把存在于磁盘的文件，整体完全映射到虚拟内存（单单是映射，可以理解为全拷贝）（大小偏移满足4k）内存上，是先有文件，再拿文件进行映射
	"||"		------->他占用虚拟内存，不占用过物理内存
	"||"	
	"||"		mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，
	"||"		（因为映射之后，在共享段里面的那一段对应的内存）
	"||"	
	"||"		map并不分配空间, 只是将文件映射到调用进程的地址空间里,------->（mmap没有进行物理内存上的操作）
	"||"	
	"||"		过这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了.
	"||"	
	"||"	========================================================================================================================================================
	"||"	mmap 
	"||"	
	"||"	1、mmap实现原理
	"||"	
	"||"	建立虚拟空间一段区域和磁盘上的文件的映射。
	"||"	
	"||"	当访问虚拟空间中该区域时，通过 MMU，得到该区域对应的物理地址，OS 发现该区域没有数据，故产生缺页中断。OS 从磁盘中读取相应页的数据直接 copy 到物理内存中。
	"||"	
	"||"	对于传统的 read 系统调用来说，他们需要将磁盘中的文件先 copy 到内核缓冲区中，再将该数据 copy 到用户缓冲区中。
	"||"	相较于 mmap ，后者节省了一次 copy ，这也就解释了为什么 mmap 相较于 read 和 write 系统调用性能较高的原因了。
	"||"	mmap 不仅可以映射到磁盘上的普通文件，还可以映射到匿名文件。实现方式是形参中的 fd = -1，flag = MAP_SHARED | MAP_ANON 。
	"||"	
	"||"	对于匿名映射来说，其目的是保证该共享内存映射区只能父子进程使用，其他进程无法访问。如果需要与其他进程访问的话，需要映射到磁盘上的实际文件中。
	"||"	
	"||"		简单说就是把一个文件的内容在内存里面做一个映像，内存比磁盘快些。
	"||"		------>可以理解为一大段假的虚拟的内存地址，他不占用物理空间，但是他有内容
	=================================================================================================================================================================
	"||"	shm 实现原理：
	"||"	通过相同的 key，实现了不同的进程的各自一段虚拟地址空间同时映射到某一段物理内存中的功能。
	"||"	
	"||"		
	"||"		shm只做内存映射，和mmap第一个功能一样！只不过不是普通文件而已，是物理内存。
	"||"		shm会开辟对应的物理内存
	"||"	========================================================================================================================================================	











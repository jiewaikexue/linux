用户模式
内核模式:在用户模式下调用系统调用就转换成了内核模式
模式切换: 一个中断,会进行两次模式切换

进程的模式切换有点费时间,


内核的功能:进程管理,文件系统,网络功能,内存管理,驱动程序,安全功能
保存现场:保存一个进程运行的现场,
恢复现场:~ 
现场信息在哪里?
        解答: 对于linux来说,每一个进程 (Process:进程是运行中的程序的一个副本(可能只运行部分代码)(进程可能会被创建多个,所以说是副本))
        内核为每一个运行在当前系统上的进程,都会创建一个用来追踪该进程的元数据结构
        也就是现场信息
        干脆就创建一个结构体:来保存这些信息(PCB)
        对于进程而言,,内核使用的结构体称之为: task struct
    linux内核存储进程信息的固定格式 task struct (任务结构体)
        通过链表来将所有的PCB链接在一(查看所有进程,就是遍历这个链表)
        多个任务的 task struct 组成的链表,就叫task list
    

    任何一个时刻,任何一个程序执行过程中,当它试图接近特权指令(环0指令)时,会立即唤醒内核,
            这时,也就触发了软中断,会立即由内核接管这个程序(eg:系统调用)

         
进程是有生命周期:

    进程创建:
        对于linux来说,内核并不负责进程.
    1.先运行内核
    2.有内核负责启动进程,该进程管理所有进程(0号进程--->init进程)
    3.内核从此回家享福,就负责当个保安,防止一般进程调用特权指令
    4.init进程创建完成后,,init负责,后续的所有的进程创建,并向内核提交
        ------>init进程负责一切用户空间进程的管理,
        ------>init进程创建其他进程,,是利用fork()
        ------>所以进程就具有了父子关系
        ------>init由上帝创建次唯一一个
        ------>其他进程是利用fork()系统调用,向内核发起请求,创建新的进程
        ------>所以.进程树概念
                内核创建init
                init创建子进程
                子进程创建子进程
                此时init一直在等待回收第一代子进程的资源
                子进程一直在等待回收孙子进程的资源.
                所以init一直存在
                所以init可以回收僵尸进程的资源
    5.进程创建fork 和clone
        创建子进程使用fork()
        子进程简单的拷贝一份父进程的pcb
        fork()特殊机制,读时共享写时复制
        读时共享:因为父子进程共用一份pcb
        写时复制:调用clone函数 复制父进程pcb的函数指针所指向的内容
    6.进程一定是白发人送黑发人



进程优先级::linux划分了固定个数的优先级等级
  笨蛋方法:每一次内核划分时间片的时候,都去遍历一遍 task struct list找到最大的优先级别的进程
    现实实现(工作模式):为了能够实现快速调用   
                linux根据固定的进程优先级,划分了140*2个队列----(运行队列,过期队列)
                调度时,只需要扫描每一个运行队列队列的首部,从高到低,找到第一个应该吊起的进程
                这样不管,某一个级别的队列中待调用的进程有多少个
                调度时,扫描的时间都是固定的


                内核会把运行过了但是还没有运行完成的进程,放入对应优先级的过期队列
                运行队列中所有的等待的进程,,全部被运行一遍后(这样就会清空了运行队列)
                内核就会去运行过期队列中的进程
                 此时,过期队列和运行队列的身份完成转化,暨过期队列成了运行队列,运行队列成了过期队列----->依次循环,不眠不休,彻底完成了,系统进程调度的基本模式


         进程优先级:0-139
            0
           1-99:实时优先级(数字越大优先级越高)
           100-139:静态优先级(用户可调用的优先级)(越小越优先)
        Nice值:(道德值哈哈哈哈)
            -20~19: 我们通过调整nice值,来调整进程优先级
            root可以随便调整
            普通用户,只能让路(调低)

task struct 解释

进程内存;
    整个内存空间由大量的Page Frame组成
    而这些Page Frame(离散的Page Frame)集中分配给一个进程
    通过一个中间层(虚拟进程地址空间)
    使得这些不连续的Page Frame在进程看来是连续的
    ---->每一个进程都认为,整个机器上运行的只有自己和内核
    ---->事实上一个进程不能用到3个g
    ---->可能只会用两个叶匡
    ------->内核只会分配给进程需要的空间
    ------->进程误认为3个g的全都是自己的
    ------->这就是一种映射关系(这种关系,,由内核维护)
    ===>32位上,每一个进程,都认为自己有3个g随便用
                进程内存空间模型(虚拟内存)
                用户区
                    code:
                    已初始化全局变量去
                    未初始化全局区
                    堆
                    共享代码区
                    栈
                内核区:
    =======>一旦物理内存不够用了:根据交换分区
            扫描物理空间
            根据lru算法(lru:最近最少使用算法)
            找到对应的Page Frame
            将其拷贝一份到交换分区上,使得内存上的Page Frame暂时能够覆写
            一旦使用完成之后.需要把交换分区的东西放回物理内存(可能和原来在物理内存中的位置不一样)
            但是此时虚拟内存和物理内存的映射关系已经被破坏了()
            此时就需要重新进行映射=====>一个进程访问某数据时,以为在自己的进程空间,但是访问后发现并不存在,此时,该数据,就要被从磁盘载入(缺页异常) ======>这里也就是实现内存映射的关键所在
                        --------------------------------------
                        |-缺页异常:
                        |-    大异常:数据本来就在硬盘上
                        |-    小异常:数据被换出到交换分区上了
                        --------------------------------------
            --常驻内存集:不能够被交换的
            --虚拟内存集:可以被交换的内存空间

    ----->>>>虚拟地址空间与物理空间之间的转换依靠MMU(内存管理单元)
                MMU负责地址的试试转换

    Page Frame :页框,用来存储页面数据
                用来存储page的
IPC :进程间通信机制==>进程间彼此不能意识到彼此的存在(每个进程以为就只有自己和内核)
    同一个主机之上:
        可以使用:
            signal:信号
            shm:共享内存 内存映射
            semerphor:
            管道:
    不同主机上的进程:
            RPC机制:也就叫做,远程过程调用()
            socket:套接字


linux内核:抢占式多任务(内核的工作模式)
进程类型:
    守护进程:daemon (和终端无关,有内核在系统引导过程中启动的进程)
    用户进程: 用户通过终端启动的进程(也可以叫做 前台进程)
        注意:也可以把在前台启动的进程,送往后台,变成守护进程
进程的状态;
        
            进程 5 种状态
            ||  1.运行态："有执行资格，有执行权"------------>被允许执行。抢到了cpu的时间碎片
            ||  2.挂起态："没有执行资格，没有执行权"------------>强制剥夺资格，释放了cpu的时间碎片 ----->满足等待条件后，就获得了执行资格（也就是就绪态）
            ||  3.就绪态："有执行资格，没有执行权" ------------>是被允许执行的，没有抢到cpu的时间碎片
            ||  4.终止态：X
            ||  5.初始态：一瞬间，一般不研究
           拓展：
                1.所有的运行态都是从就绪态转过去的
                2.所有的挂起态，都是从运行态转过去的

        i/o过程:意味着进程需要的资源在物理内存中没有
                于是不得不请求内核,把数据从磁盘装入内存

                i/o过程分为两段:
                    1.因为进程没有权利直接从磁盘加载
                    2.所以进程会想内核提出申请,由内核将磁盘数据加载到内存
                    3.但是内核加载数据,只是将数据,加载到内核自己的内存中去,和进程的内存无关
                    4.所以,i/0一定是先将数据,装载到内核内存
                    5.然后,将内核内存装入到进程的内存
                    6.所以i/o一次,,会发生2段操作 上述 4 5
                    7.只有第二段系统调用,叫做真正的i/o 第一步叫做装入
                    8.i/o是不可中断的

进程根据占用cpu护士i/o多少来分类
    CPU-Bound:cpu密集型
    IO-Bound: IO密集型


<<linux内核设计与实现>>入门
<<深入理解linux内核>>四库全书
<<linux内核的架构体系>> 升华

centos5和6的启动弄流程
        linux:  1.内核(kernel)
                2.rootfs(根文件系统)(找根文件系统)
                3.运行init(找init找不到,没人去管理用户空间啊)(init一旦跑起来,内核就退休了,用户空间几乎都是init管)
                4.init根据

            内核的功能:进程管理 
                       内存管理:malloc申请分配内存,free这俩就是一个系统调用
                       网络管理:每一个服务内进程,要想监听在套接字上
                                必须向内核中的网络功能发起调用
                       驱动程序:
                       文件系统:read openclose write什么的都是文件系统的系统调用
                       安全功能:selinux,权限模型也是linux的一部分
                                
            rootfs:根文件系统
                   glibc:标注库,把很多系统调用,封装一遍,在运行的时候已经
                            在/lib64 /usr/lib64


            库:到底是什么?
                    库是一个函数的集合
                    库文件没有用自我执行的入口
                    可以作为别的程序的代码片段
            

            程序:很重要,一个操作系统的重要拓展就是二进制程序
    ----------------------------------------------------------------------
    内核是一个操作系统的基石:
            内核设计流派:
                    1.单内核设计:linux
                        --->解释:把所有功能集成到同一个程序中
                    2.微内核设计:  windows
                        --->解释:每种功能使用一个子系统实现,然后在一个大框架下共同工作
            linux内核特点:
                    1.(内核)支持模块化(就是内核模块):
                            .ko文件就是内核模块
                            支持模块的动态装载和卸载模块(内核在线状态)
                            硬件的驱动需要内核其使用,
                            硬件厂商,负责硬件程序的保障
                            然后用户要用自己加上去就行了
                            ---->文件系统就是一个模块化

                    2.

    <1>  linux内核的组成部分:
              -----------------------------------------------------------------------------
              |      1.和弦文件: /boot/vmlinuz-版本号-release号(rpm包的00  )
              |          本机: /boot/vmlinuz-3.10.0-1062.18.1.el7.x86_64 
              |      2.模块文件: /lib/modles/
              |         本机:
              |              1. ll /lib/modules/3.10.0-1062.18.1.el7.x86_64/
              |                  -->这个目录下面,有很多模块间依赖关系的元信息
              |              2. ll /lib/modules/3.10.0-1062.18.1.el7.x86_64/kernel
              |        jie@VM-0-9-centos 1_centos启动路程]$ ls /lib/modules/3.10.0-1062.18.1.el7.x86_64/kernel/
              |                 arch  crypto  45322222222222222222222222222222222222drivers  fs  kernel  lib  mm  net  sound  virt
              |                 arch:平台相关的内容
              |                 crypto:内核中加密解密等安全先关的内容
              |                 drivers:驱动
              |                 fs:文件系统
              |                 kernel:内核基本功能
              |                 lib:库文件
              |                 mm:内存管理
              |                 net:网络相关
              |                 sound:声音相关
              |      3.rundisk:这对于centos5和centos67上不一样
              |                  centos5上模拟成硬盘
              |                  ---->/boot/initrd-VERSION=release.img
              |                  centos76上是模拟文件系统:
              |                  ---->/boot/initramfs-VERSION-releas.img
              |          解释这个东西:
              |          ---------------------------------------------------------
              |          |-   centos启动流程,首先是要唤起内核
              |          |-   内核环形之后,会去寻找根文件系统(rootfs)
              |          |-   但是rootfs是在磁盘上的
              |          |-   所以就必须要去找到对应的磁盘
              |          |-   但是磁盘的驱动,是一个内核的模块
              |          |-   这个模块在/lib/modules/xxxx下面
              |          |-   这个目录是存在于根文件系统下面的
              |          |-   现在这个尴尬的情况就是
              |          |-   我要找rootfs就必须要找到磁盘
              |          |-   我要找到磁盘就必须要先装上驱动
              |          |-   但是我TM的驱动又是挂载在根文件系统上的,------>这玩意就是一个闭环.无解
              |          |-   为了解决这种情况,
              |          |-   引入了rundisk机制
              |          |-   rundisk是一个伪根文件系统,他是在整个centos系统安装完成之后
              |          |-   自动生成的一个带有必要的相关驱动的文件,
              |          |-   就是为了解决上述闭环的.
              |          |-   所以centos在启动之后,第一件事,是去找驱动.
              |          |-   驱动从rundisk这个伪文件系统上找到的.
              |          |-   找到之后,由于内核在启动init也就是systemd进程之后,就会退休
              |          |-   但是,rundisk这个伪文件系统上面,并没有类似于rootfs上面各种lib和程序
              |          |-   最主要的是init在rootfs上.
              |          |-   所以就必须,完成文件系统的切换.=====>暨有rundisk 切换到 rootfs上
              |          |-   之后启动init/systemd进程,之后内核退休
              |          ---------------------------------------------------------
              -----------------------------------------------------------------------------
    <2>centos启动流程
            
            引言:
                x86架构:启动流程
                    POST:加电自检------->整个硬件系统检测硬件系统层面上是否正常
                            这个过程和ROM芯片有关
                            ROM:CMOS(ROM没电了也不丢失数据)
                                
                                BIOS:basic input and output system:这玩意也是个程序,装在ROM上
                                ------->bios 是依靠cpu的

                            ROM+RAM=内存
            1.完成自检之后,cpu通电之后,第一件事  cpu要完成自举
                
                自举: 1.装载指定位置的指令:(由rom提供的)
                        进行加电自检.
                        如果成功,则运行bios
                      2.加载bios,启动设定界面(这个界面可以跳过)(f2)
                            如何区分多块硬盘,那一块是os盘?
                            bios设定里面有一个很重要的选项 BOOT Sequence:引导加载次序

                                设备引导次序:决定了引导设备加载的次序
                                引导设备上,必须要有MBR
                                MBR前416字节是BOOT LOADER(设备引导加载器)(MBR磁盘引导区域,前512字节)
                                如果没有引导加载器,会直接跳过这个设备
                                任何一次启动过程中,找到第一个具有MBR(因为mbr里面有boot loader)的设备
                                找到之后,无论结果如何,不会加载在此之后的设备
                                    ------->所以第一引导设备至关重要
            2.按次序场照哥哥引导设备,第一个有引导程序的设备
              就是本次启动用到的设备,然后运行bootloader
              装载内核,权限移交,bios退休
             
                boot lader:引导加载器: 
                            1.windows平台:ntlodaer
                            2.linux:有两种  1.LILO:LINUX LODER (LINUX装载器)
                                            2.GRUB: GRAND UNIFORM BOOTLOADER (统一引导加载器)
                                                        |-grub0.x:grub传统版
                                                        |- grub1.x:grub2
                                                        |- grub用一种非常牛逼的方法  使得bootloader可以突破442字节
                                                                    |- 1.grub将整个 bootlader分成了3各阶段
                                                                    \\第一阶段:   位于MBR,bootloader中
                                                                        第一阶段的唯一功能,就是找到位于硬盘上的第二阶段
                                                                    \\第1.5阶段:帮助grub识别文件系统.
                                                                                第1.5阶段,紧跟在MBR之后
                                                                                这个文件系统,是在操作系统安装完成之后就确认了的

                                                                    \\第二阶段:   都在硬盘上了,随便搞(空间不是事情)
                bootloader的功能:
                            提供一个菜单,允许用户选择要启动的系统或是不同的内核版本:
                            把用户选定的内核,装载到内存的特定非空间中,
                            然后把内核展开(因为内核是压缩存放的)
                            并且把系统的控制权转交给内核
                            bios使命完成,,自动终止

                MBR:0磁道0扇区,主引导记录 446+64+2
                                bootloader+磁盘分区表(fat)+55AA
           3.内核自身初始化:
                内核自解压,
                探测可识别到的所有硬件设备,
                装载相关驱动:此处有可能会借助于 rundisk 加载驱动 (这个一定是在rootfs前)
                挂载rootfs,
                吊起init/systemd:也就是用户空间的第一个用户程序 init
                                    ====>init的类型
                                         1.systemV风格的: init(centos5)
                                                    |- /etc/inittab
                                         2.Upstart: init  centos6
                                                    |- /etc/inittab /etc/init/*.conf
                                         3.systemd: 不需要bashshell参与  centos7
                                                    |-  /usr/lib/systemd/system
                                                    |-  /etc/systemd/system
                                                    ---->启动服务:systemctl
                                                    
                ------>内核在任何时候,加载rootfs时,都只能以只读的方式进行加载
                ------>只有在后期,系统彻底启动后,rootfs以可读可写的方式进行重挂



    内核的特性之一:使用缓冲和缓存来加速对磁盘上文件的访问
                ramdisk------->ramfs ;因为ramdisk会被缓冲两次 
                        centos 5:initrd
                                |- 用mkinitrd来生成
                        centos 6:initramfs
                                |- 使用dracut来生成

           4.(内核退休)后续的所有操作,都是init的任务了 


总结:
    加电自检--->根据bios去寻找引导加载次序----->寻找bootloader----->选择内核版本装入内存
    ------>内核自解压----->.....----->唤起init----->根据init程序的种类(三种风格)继续后续的操作

exec函数族:

IPC：进程间通信，inter process communication
	4种方式：
		·	1.管道---简单(伪文件！)
		·	2.信号--系统开销小
		·	3.共享映射区--(有无血缘关系都可以)
		·	4.本地套接字----稳定
				
				

		:文件（普通文件是非阻塞的）
				
					d 目录
				
					l 符号链接
				
		:伪文件
					s 套接字
				
					b 块设备
				
					c 字符设备
				
					p 管道
				
				
				
>1<管道:  (简单)--->读完就擦
	    ·	1.本质：
	    		1.在内核缓冲区中
	    		2.管道是  为文件。----->不占用磁盘空间
	    ·	2.特点

	           =================================================================================
	    	==
	    	==	1.管道分为两部分，分别对应两个文件描述符
	    	==			1.读端：读出
	    	==			2.写端：写入
	    	==			
	    	==		"       这 是 一 个 环 形 队 列+++++++++++++++马哥数据结构！！！！！
	    	==			 ———————————————————————————————————
	    	==		fd0	|									|	fd1
	    	==			|		<-------------------		|
	    	==			 ———————————————————————————————————
	    	==    "
	    	==			 	
	    	==	2.操作管道的进程，被销毁之后，管道被自动释放 （操作系统级别的）
	    	==	
	    	==	3.管道默认是阻塞的：读写都是默认阻塞的 ！！！
	    	==	
	    	==	4.内部实现方式：队列（环形队列，先进先出）
	    	==	
	    	==	5.大小默认是 4K byte 会适当的调整，是有一定范围的





	    				=========================================================================
	    			"||"PIPE_BUF：4k---->当读写数据小于 PIPE_BUF时，保证读写的原子性
	    			"||"		  什么是原子性： 当前操作不能被打断，不论是读写都不能被打断
	    			"||"		  				------>引申：当前操作要么是完成了，要么是还没有完成，不存在完成一半的情况
	    			"||"
	    			"||"		  				
	    			"||"		  什么是临界资源：PIPE——BUF ：4k是 是临界资源
	    			"||"						同一时刻，当前的资源只能被一个进程所访问；
	    			"||"				如果多个进程同时修改临界资源，会导致数据二义性。
	    			"||"				
	    			"||"				问题！！===+如何保证临界资源访问的合理性，从而不会造成数据二义性
	    			"||"						互斥：同一时间，保证了只能有一个进程访问临界资源
	    			"||"						同步：保证了不同进程对临界资源访问的合理性
					


						=============================================================================
					PIPE_SIZE：64k





	    	==	
	    	==	6.管道的局限性：
	    	==		1.数据只能读取一次，不能重复读取。
	    	==		2.半双工：
	    	==		3.匿名管道只适用于 ---->有血缘关系的 进程
	    	==		
	    		=============================================================================
	    3.创建匿名管道
	    	1.int pipe（int fd[2]);
				-1.fd是一个传出参数，fd是俩文件描述符
				-2.fd【0】----读端
				-3.fd【1】----写端
				-4.！！！pipe要写在fork的前面！ -------->子进程继承父进程的pcb，pcb里面有文件描述符表
		4.父子进程建使用管道
			思考！：
				1.单个进程能否使用管道？
				------= 可以。我甚至可以把管道当成一块内存，专门写垃圾
				2.父子进程之间通信，是否需要sleep函数？
					情景：父进程：写的慢  子进程：读得快

					-------->不需要！  
							---->因为管道默认是  阻塞的

		5.父子进程间通信，很多时候回用到文件重定向，dup/dup2

		6.管道的读写行为：
				-1.读操作
	
				 		 1.1：有数据
				 		 		读端正常读，read返回读出的字节数
				 		 1.2：无数据
				 		 	1.2.1：假设写端全部关闭：read接触阻塞，返回0--->相当于读到文件尾部
				 		 	1.2.2：写端没有被全部关闭：---->read会阻塞，等待写端写入数据
				-2写操作
						2.1：读端全部被关闭：
							 管道破裂，进程终止（内核会给进程发13号信号，会杀死写端）
						
						2.2：读端没有全部被关闭
							2.2.1：缓冲区写满了---->阻塞 等待空位，有空位在写
							2.2.2：缓冲区没有满---->继续写，直到写满
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

							读写行为汇总！
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
			======================================================================================================
			|| 		
			||						几种特殊情况：https://blog.51cto.com/11285984/1835413
			||++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			||				"默认read 和 write 都是 阻塞状态 ，因为文件创建出来默认就是阻塞的"
			========================================================================================================			 
		"	===			 (1)如果	所有指向管道写端	的文件描述符都关闭了，
			===			 而仍然会有进程从管道的读端读数据，那么当管道中的数据被读取完之后，
			===			 再返回0，就像读到文件末尾一样。
			===
			===						
			===
			===			 (2)如果有指向管道写端的文件描述符没关闭，
			===			 而持有管道写端的进程没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据被读取后，
			===			 再次read会被阻塞，直到管道中有数据可读了才读取数据并返回。
			==="
			===			 		 管道的另一端是否关闭，会影响本端，在进行相关操作时，是否会阻塞（eg：写端不关，读端读完就阻塞，等着。读端不关，写端写满就阻塞，等着）
			===					 	（另一端的是否关闭，可以用来判断是否进行  进程间持续通信）（端口的关闭与否，，可以看做一种 握手挥手机制）
			"===	
			===			 (3)如果 所有 指向管道读端		的文件描述符都关闭了，
						
			===			 这时有进程向管道的写端write，
			===			 那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。
			==="
			===		         	管道的读端要比写端高贵，从根本目的上来说，管道就是为读端而服务的    
			===					这也是处于对读端的保护
			"===
			===  				
			===
			===			 (4)如果有指向管道读端的文件描述符没关闭，
			===			 而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写数据，
			===			 那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。
			======================================================================================================================="
			===				更改读写段的状态为非阻塞：下设2种情况
			========================================================================================================================
			===  				1.变更 write 状态为非阻，读端不变
			===
			===			1.1： 一直写入，但是不进行读，并且读端不关闭：（一直写入时因为write是非阻塞的，所以可以一直写）
			===				  write  会返回-1，报错当前资源不可用，
			===			（个人理解：非阻塞会一直写下去，"当队尾遇到队头"，就应该会停下来，若果不停下来，就证明写多了，所以返回-1）
			===					所以报错，但是咱满足大小的范围内，会读取成功（）
			===
			===			1.2： 所有读端直接关闭，
								写端一直写，（没有写入操作，会在最开始被杀死）（"管道的读端要比写端高贵，从根本目的上来说，管道就是为读端而服务的"）
			===					当前京城会受到13号信号，写端会被杀死。（管道破裂了）（管道读端一定要开放）
			===					（读端不要数据时，关闭读端，，杀死写端，这也是一种保护机制）
			===+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			===
			===					2.变更读端，read设置为非阻塞，
			===
			===			2.1：写端不关闭，read一直读，read会返回-1，
			===						(循环双端队列，"队头遇到队尾"，还不停下来，还不要命的读，就会出错)
			=== 		2.2：所有写端关闭
								，读端一直读， read是正常调用的，read会返回到的字节数
			===					("写端关闭，就意味着没有新数据"，队头遇到队尾就停下来)
			================================================================================================================
			===			AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
			===			A 		'管道在使用时，会先检查读写端的引用计数
			===			A					如果读端为0 则破裂
						A					如果写端为0 ，就返回字节数而不是数据流';
						AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
			==================================================================================



		7.查看管道大小：
			1.使用shell命令： ulimit -a 一般默认是4k但是会管道会石洞扩大
			2.函数： fpathconf

				   #include <unistd.h>

     			    long fpathconf(int fd, int name);
       				long pathconf(char *path, int name);
       				参数
       					：fd文件描述符
       					name：   _PC_PIPE_BUF 一大堆宏

       	8.设置管道阻塞状态：
       		（管道的莫一端的彻底阻塞，是要看 这一端的引用计数  4根线1刀切）

       		"=====================>>>>>>>>"	||	fcntl 函数
								||			改变已经打开的文件的属性
								||			int fcntl(int fd, int cmd ....)
								||			参数：fd：文件描述符
								||				   cmd：改变文件描述符属性
								||				打开文件的时候: 只读
								||						修改文件的: 添加追加 O_APPEND
								||	
								||			获取文件flags:
								||					int flags= fcntl(i fd, F_GETFL );
								||			设置文件新的flags：
								||	
								||				flags|=O_NONBLOCK;(设置文件为阻塞状态)
								||				fcntl( fd, F_SETFL,,falgs0
								||	




>2< fifo（和匿名管道一样，默认阻塞）
	
		1.特点：	
			1.1 有名管道：
			1.2 区别于匿名管道
					1.2.1 fifo是在磁盘上的一个文件，，是一个管道文件
						ls -l   会显示一个 p
					
					1.2.2 .fifo也是一个伪文件，fifo的大小永远是0
					1.2.3 .在内核中有一个缓冲区
					1.2.4 .半双工
			
		2.使用场景：没有血缘关系的进程间通信

		3.创建方式：
			<1>第一种： shell命令行
				mkfifo  name

			<2>第二种 函数
				    #include <sys/types.h>
       				#include <sys/stat.h>

     				int mkfifo(const char *pathname, mode_t mode);
     					参数：
     					pathname------>带路径文件名称
     					 mode： 八进制树----->文件权限 mode会& ~umask
     				如果没有则创建，有的话创建失败



     	4.进程间通信：fifo
     	eg：两个不相干进程 a.c b.c
     		a.c---->read
     			int fd =open("myfifo",O_RDONLY);
     			read(fd,buf,sizeof(buf));
     			close(fd);
     		b.c---->write
     			int fd1=open("myfifo",O_WROMLY);
     			write(fd1,"xxxxxxxx",sizeof(xxxxxxx));
     			close(fd1)
     				
			====================================================================================================
								也就相当于从4根线，变成了2根线
			||	*（1）open() 以只读方式打开 FIFO 时，要阻塞到某个进程为写而打开此 FIFO；
			||	　  		
			||		
			||			open() 以只写方式打开 FIFO 时，要阻塞到某个进程为读而打开此 FIFO。
			||						简单一句话：
			||						open时	只读等着只写（没有东西就等着），只写等着只读（写满了就等着读出空位），
			||								只有两个都执行到，才会往下执行。
			||		
			||				如果不想在 open() 的时候阻塞，我们可以以可读可写方式打开 FIFO 文件
			||				------->这样 open() 函数就不会阻塞。
			||				------->这是针对于open阻塞相互等待的解决办法
			||				------->解决之后，默认read 和write是阻塞的 管道还是正常的操作
			||"====================================================================================================="				
			||		
			||		2）假如 FIFO 里没有数据，调用 read() 函数从 FIFO 里读数据时 read() 也会阻塞。这个特点和无名管道是一样的。
			||		
			||		3）通信过程中若写进程先退出了，就算命名管道里没有数据，
			||			调用 read() 函数从 FIFO 里读数据时不阻塞；（一根线断掉了，就不是非阻塞的了）（读取成功后，返回读取的数据多少）
			||			若写进程又重新运行，则调用 read() 函数从 FIFO 里读数据时又恢复阻塞。（那根线又连上了）
			||
			||		5）通信过程中，读进程退出后，写进程向命名管道内写数据时，写进程也会（收到 SIGPIPE 信号）退出。
			||					（一根线断掉了，还是读端的那根线，管道破裂）（断线之后，引用计数为0）
			||				(3和5就已经是 一刀斩断所有引用了）（这个引用我是进程保持的，你如果手动关闭这个fd也会出问题，直接退出也会出问题
			||		6）调用 write() 函数向 FIFO 里写数据，当缓冲区已满时 write() 也会阻塞。
			||				（默认阻塞）
			||"======================================================================================================="		
			||		
			||		命名管道可以以非阻塞标志（O_NONBLOCK）方式打开：
			||		fd = open("my_fifo", O_WRONLY|O_NONBLOCK);  
			||		fd = open("my_fifo", O_RDONLY|O_NONBLOCK); 
			
					AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA	
			||				-------- >以此方法打开管道后， 管道就是非阻塞的了
			||				-------- >同时 open也非阻塞了
					AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
			
			||		非阻塞标志（O_NONBLOCK）打开的命名管道有以下特点：
			||		1、先以只读方式打开，如果没有进程已经为写而打开一个 FIFO, 只读 open() 成功，并且 open() 不阻塞。
			||		2、先以只写方式打开，如果没有进程已经为读而打开一个 FIFO，只写 open() 将出错返回 -1。 
			||
			||				------这里并不是13号信号，这么整的话，会认为你创建管道失败
			||				------你可以一直循环来进行  非阻塞open 知道创建成功
			||		3、read()、write() 读写命名管道中读数据时不阻塞。
			||	
			=====================================================================================================================













				
				

























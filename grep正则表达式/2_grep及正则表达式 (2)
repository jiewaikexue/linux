    linux文本处理三剑客
        grep：文本过滤（模式：pattern）工具
        sed：stream editor流编辑器：是个文本编辑工具
        awk：linux上的实现gawk。这是个文本报告生成器。

<1>grep:Global search REgular expression and Print out the line
        作用：文本搜索工具，根据用户指定的”模式”，对目标文本逐行进行匹配检查。打印匹配到的行。
        模式：有正则表达式字符及文本字符，锁编写的过滤条件
                ||可以只是用基本字符
                
        REGEXP（正则表达式）：由一类特殊字符及正常的文本字符编写的模式。其中有些字符不表示字符的字面意义，而表示控制，或者是通配的功能。
                ||正则表达式分两类
                =============
                = 1.基本正则表达式：BRE（grep默认）
                = 2.扩展的正则表达式：ERE（egrep能使用这个）
                =============
                grep：支持基本正则表达式（默认是BREE）
                        ||-E：支持ERE
                egrep：默认支持ERE
                fgrep：压根不支持ERE

        ====>>正则表达式引擎：主要用来实现正则表达式解析和匹配检查

====>>
====>>
    grep命令：
        --color=auto：对匹配到的问呗着色显示
        -v：显示不能被pattern（模式）匹配到的行
        -E：使用扩展正则表达式ERE
        -G：使用基本正则表达式BRE相当于egrep
        -F：使用固定字符串相当于fgrep
        -i：匹配检查是忽略字符大小写
        -o：进显示匹配到的字符串，进现实匹配到的字符串本身
        -q：（静默模式）检查匹配后不向屏幕输出任何信息
        -A #：显示匹配得到的行，及以后的#行
        -B #：显示匹配得到的行，及以前的#行    
        -C #：显示匹配到的行，及前#行，后#行




    基本正则表达式元字符：
        字符匹配：
            ======================================
            ||    .号：匹配任意单个字符---->有点像？
            ||    []:匹配任意范围内的任意单个字符
            ||    [^]:匹配指定范围外的任意单个字符===>字符集合glob一样
            ======================================
            ||    grep里的元字符，需要用引号引起来。
            ||    单引号：强引用---->直接检查每一个字符串。元字符一样会被解释
            ||    双引用：弱引用---->双引号引起来的变量，会被先替换掉
            ======================================
            ||    无脑引用就行了
            ======================================
        匹配次数:用在要指定次数的字符后面，用于指定前面字符出现的次数
            ======================================
            ||    *：匹配前的字符任意次：----->glob里面表示万能匹配
            ||            ||0-无限次
            ||            ||能匹配多少就匹配多少---->默认情况下正则表达式引擎是贪婪模式
            ||
            ||    .*：任意长度的任意字符
            ||        ||.号任意字符
            ||        ||*：任意长度度
            ||        ||.*《=====》和glob的*一样
            ||
            ||    \?：匹配前面字符0次或一次：暨前面的字符可有可无
            ||    \+:匹配前面字符至少一次：
            ||    \{#\}:匹配前面的字符#次：精确指定匹配次数
            ||    \{#,#\}：匹配前面的字符，#-#次，是一个闭区间
            ||            ||\{0,n\}：匹配前面的字符0-n次
            ||            ||\{m，\}:匹配前面的字符至少m次
            ==================================================
        位置锚定：
            ==================================================
            ^:行首锚定。出现在模式最左侧
            $:行尾锚定。模式的最右侧
            ^xxx$：用于模式匹配整行。
            ^$：空行：
            ^[[:space:]]*$:空白行 
            --------------------------------------------------
            \<或\b:词首锚定：用于单词模式的左侧
            \>或\b：词尾锚定，用于单词模式的右侧
            \<XXXXX\>：匹配整个单词，用于单词的左右两侧
            ==================================================
        分组：合并
        \(\):将任意个字符捆绑在一起，当做一个整体
            Note：分组括号中的模式匹配到的内容，会被正则表达式，记录到引擎的内部变量之中
                    ||这些变量的命名方式为：\1 \2 \3......
                    ||\1：表示第一个左括号，以及与之匹配的右括号之间的模式所匹配的字符
                    ||\2：表示第二个左括号，以及与之匹配的有括号之间的....
            后向引用：引用前面分组括号中的模式锁匹配的字符（而非模式本身）
    练习：
        显示/proc/meminfo文件中以大小写s开头的行：（要求使用两种方式）    
        显示/etc/passwd中不以/bin/bash结尾的行
        显示/etc/passwd文件中，id号最大的用户的用户的用户名
        如果root用户存在，，显示其默认的shell程序
        找出/etc/passwd文件中的两位或者三位数；
        找出/etc/r.d/rc.sysinit文件中至少一一个空白字符开头的行切后面存在任意个非空白的行
        找出netstat -tan命令的结果中以LISTEN后跟0，1或多个空白字符结尾的行
        添加用户 bash testbash basher 以及nologin（要求其shell为/sbin/login）找出etc passwd文件中用户名同shell名的行
